# 5.1.1 01背包

## 5.1.1.1 什么是01背包

01背包主要用来描述以下的一类问题

> 经典的01背包问题
> 给定几种物品，并且每种物品有且仅有1件，且有两个维度的参数：体积和权值。
> 问：给定一个指定体积的容器，求在不超过容器容量限制的情况下最多可以放下的物品的权值之和。
> 由于每种物品只有1件可得到一下思维flow：
> 物品的最大权值之和的问题 >>> 物品的选择 >>> 每件物品的选与不选的问题

## 5.1.1.2 经典例题

**问题**

有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。

第 $i$ 件物品的体积是 $vi$，价值是 $wi$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数$N，V$，用空格隔开，分别表示物品数量和背包容积。

接下来有 $N$ 行，每行两个整数 $vi,wi$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N,V≤1000$
$0<vi,wi≤1000$

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**

```
8
```

## 5.1.1.3 模板代码

```c++
#include <iostream>
using namespace std;

const int N = 1010; // 容器的容量
int v[N], w[N]; // 每件物品占用的体积v和价值w
int f[N]; // 体积占用为N的情况下可以装下的物品的最大总价值

int main() {
    int n, m; // 物品的种类，容器的容量
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i ++) {
        /* 
            当前物品选与不选的抉择
            从m->1的原因是需要在上一次的数据的基础上迭代
            如果反之使用1->m则由于当前轮次已经迭代到了j-1所以就丢失了上一轮的数据
         */ 
        for (int j = m; j >= v[i]; j --) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```
